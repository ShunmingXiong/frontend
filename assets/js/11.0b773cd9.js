(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{602:function(t,a,e){"use strict";e.r(a);var r=e(17),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react原理揭秘"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react原理揭秘"}},[t._v("#")]),t._v(" React原理揭秘")]),t._v(" "),e("h2",{attrs:{id:"目标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#目标"}},[t._v("#")]),t._v(" 目标")]),t._v(" "),e("ul",[e("li",[t._v("能够说出React组件的更新机制")]),t._v(" "),e("li",[t._v("能够对组件进行性能优化")]),t._v(" "),e("li",[t._v("能够说出虚拟DOM和DIff算法")])]),t._v(" "),e("h2",{attrs:{id:"组件更新机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件更新机制"}},[t._v("#")]),t._v(" 组件更新机制")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("setState() 的两个作用")]),t._v(" "),e("ul",[e("li",[t._v("修改state")]),t._v(" "),e("li",[t._v("更新组件")])])]),t._v(" "),e("li",[e("p",[t._v("过程：父组件重新渲染时，也会重新渲染子组件，但只会渲染当前组件子树（当前组件以其所有子组件）")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"组件性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件性能优化"}},[t._v("#")]),t._v(" 组件性能优化")]),t._v(" "),e("h3",{attrs:{id:"减轻state"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#减轻state"}},[t._v("#")]),t._v(" 减轻state")]),t._v(" "),e("ul",[e("li",[t._v("减轻state：只存储跟组件渲染相关的数据（比如：count/ 列表数据 /loading等）")]),t._v(" "),e("li",[t._v("注意：不用做渲染的数据不要放在state中")]),t._v(" "),e("li",[t._v("对于这种需要在多个方法中用到的数据，应该放到this中")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E5%87%8F%E8%BD%BBstate.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"避免不必要的重新渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免不必要的重新渲染"}},[t._v("#")]),t._v(" 避免不必要的重新渲染")]),t._v(" "),e("ul",[e("li",[t._v("组件更新机制：父组件更新会引起子组件也被更新，这种思路很清晰")]),t._v(" "),e("li",[t._v("问题：子组件没有任何变化时也会重新渲染")]),t._v(" "),e("li",[t._v("如果避免不必要的重新渲染？")]),t._v(" "),e("li",[t._v("解决方式：使用钩子函数 shouldComponentUpdate(nextProps, nextState)\n"),e("ul",[e("li",[t._v("在这个函数中，nextProps和nextState是最新的状态以及属性")])])]),t._v(" "),e("li",[t._v("作用：这个函数有返回值，如果返回true，代表需要重新渲染，如果返回false，代表不需要重新渲染")]),t._v(" "),e("li",[t._v("触发时机：更新阶段的钩子函数，组件重新渲染前执行(shouldComponentUpdate => render)")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/shouldComponentUpdata.png",alt:""}})]),t._v(" "),e("h4",{attrs:{id:"随机数案例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#随机数案例"}},[t._v("#")]),t._v(" 随机数案例")]),t._v(" "),e("p",[t._v("需求：随机生成数字，显示在页面，如果生成的数字与当前显示的数字相同，那么就不需要更新UI，反之更新UI。")]),t._v(" "),e("p",[t._v("利用nextState参数来判断当前组件是否需要更新")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class App extends React.Component {\n    state = {\n        number: 0\n    }\n    // 点击事件，每次点击生成一个随机数\n    hanldeBtn = () => {\n        this.setState({\n            number: Math.floor(Math.random() * 3)\n        })\n    }\n    // 将要更新UI的时候会执行这个钩子函数\n    shouldComponentUpdate(nextProps,nextState) {\n         // 判断一下当前生成的 值是否与页面的值相等\n         if(nextState.number !== this.state.number){\n             return true\n         }\n         return false\n    }\n    render() {\n        return (\n            <div>\n                随机数：{this.state.number} <br />\n                <button onClick={this.hanldeBtn}>生成随机数</button>\n            </div>\n        )\n    }\n}\n")])])]),e("p",[t._v("利用props参数来判断是否需要进行更新")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class App extends React.Component {\n    state = {\n        number: 0\n    }\n    // 点击事件，每次点击生成一个随机数\n    hanldeBtn = () => {\n        this.setState({\n            number: Math.floor(Math.random() * 3)\n        })\n    }\n\n    render() {\n        return (\n            <div>\n                <NumberBox number={this.state.number} />\n                <button onClick={this.hanldeBtn}>生成随机数</button>\n            </div>\n        )\n    }\n}\nclass NumberBox extends React.Component {\n    // 将要更新UI的时候会执行这个钩子函数\n    shouldComponentUpdate(nextProps, nextState) {\n        // 判断一下当前生成的 值是否与页面的值相等\n        if (nextProps.number !== this.props.number) {\n            return true\n        }\n        return false\n    }\n    render() {\n        return (\n            <h1>随机数：{this.props.number} </h1>\n        )\n    }\n}\n")])])]),e("h3",{attrs:{id:"纯组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#纯组件"}},[t._v("#")]),t._v(" 纯组件")]),t._v(" "),e("h4",{attrs:{id:"作用以及使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用以及使用"}},[t._v("#")]),t._v(" 作用以及使用")]),t._v(" "),e("ul",[e("li",[t._v("纯组件： PureComponent 与 React.Component 功能相似")]),t._v(" "),e("li",[t._v("区别： PureComponent 内部自动实现了 shouldComponentUpdate钩子，不需要手动比较")]),t._v(" "),e("li",[t._v("原理：纯组件内部通过分别比对前后两次 props和state的值，来决定是否重新渲染组件")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/PureComponent.png",alt:""}})]),t._v(" "),e("h4",{attrs:{id:"实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),e("ul",[e("li",[t._v("说明：纯组件内部的对比是 shallow compare（浅层对比）")]),t._v(" "),e("li",[t._v("对于值类型来说：比较两个值是否相同")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%AF%94%E5%AF%B9.png",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("引用类型：只比对对象的引用地址是否相同")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%AF%94%E5%AF%B9.png",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("注意：state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E6%B3%A8%E6%84%8F%E7%82%B9.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"虚拟dom和diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom和diff算法"}},[t._v("#")]),t._v(" 虚拟DOM和Diff算法")]),t._v(" "),e("ul",[e("li",[t._v("React更新视图的思想是：只要state变化就重新渲染视图")]),t._v(" "),e("li",[t._v("特点：思路非常清晰")]),t._v(" "),e("li",[t._v("问题：组件中只有一个DOM元素需要更新时，也得把整个组件的内容重新渲染吗？ 不是这样的")]),t._v(" "),e("li",[t._v("理想状态：部分更新，只更新变化的地方")]),t._v(" "),e("li",[t._v("React运用的核心点就是 虚拟DOM 配合 Diff 算法")])]),t._v(" "),e("h3",{attrs:{id:"虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),e("p",[t._v("本质上就是一个JS对象，用来描述你希望在屏幕上看到的内容")]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E8%99%9A%E6%8B%9FDOM.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[t._v("#")]),t._v(" Diff算法")]),t._v(" "),e("p",[t._v("执行过程")]),t._v(" "),e("ul",[e("li",[t._v("初次渲染时，React会根据初始化的state（model），创建一个虚拟DOM对象（树）")]),t._v(" "),e("li",[t._v("根据虚拟DOM生成真正的DOM，渲染到页面")]),t._v(" "),e("li",[t._v("当数据变化后(setState())，会重新根据新的数据，创建新的虚拟DOM对象（树）")]),t._v(" "),e("li",[t._v("与上一次得到的虚拟DOM对象，使用Diff算法比对（找不同），得到需要更新的内容")]),t._v(" "),e("li",[t._v("最终，React只将变化的内容更新（patch）到DOM中，重新渲染到页面")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/diff%E7%AE%97%E6%B3%95.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"代码演示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码演示"}},[t._v("#")]),t._v(" 代码演示")]),t._v(" "),e("ul",[e("li",[t._v("组件render()调用后，根据状态和JSX结构生成虚拟DOM对象(render()方法的调用并不意味着浏览器进行渲染，render方法调用时意味着Diff算法开始比对了)")]),t._v(" "),e("li",[t._v("示例中，只更新p元素的文本节点内容")]),t._v(" "),e("li",[t._v("初次渲染的DOM对象")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E5%88%9D%E6%AC%A1%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E5%AF%B9%E8%B1%A1.png",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("数据更新之后的虚拟DOM对象")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E5%AF%B9%E8%B1%A1.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),e("ul",[e("li",[t._v("工作角度：应用第一，原理第二")]),t._v(" "),e("li",[t._v("原理有助于更好的理解React的自身运行机制")]),t._v(" "),e("li",[t._v("setState() 异步更新数据")]),t._v(" "),e("li",[t._v("父组件更新导致子组件更新，纯组件提升性能")]),t._v(" "),e("li",[t._v("思路清晰简单为前提，虚拟DOM和Diff保效率（渲染变化的组件）")]),t._v(" "),e("li",[t._v("虚拟DOM -> state + JSX")]),t._v(" "),e("li",[t._v("虚拟DOM最大的特点是 脱离了浏览器的束缚，也就是意味着只要是能支持js的地方都可以用到react，所以为什么说react是可以进行跨平台的开发")])]),t._v(" "),e("h1",{attrs:{id:"react路由基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react路由基础"}},[t._v("#")]),t._v(" React路由基础")]),t._v(" "),e("h2",{attrs:{id:"目标-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#目标-2"}},[t._v("#")]),t._v(" 目标")]),t._v(" "),e("ul",[e("li",[t._v("能够说出React路由的作用")]),t._v(" "),e("li",[t._v("能够掌握-react-router-dom的基本使用")]),t._v(" "),e("li",[t._v("能够使用编程式导航跳转路由")]),t._v(" "),e("li",[t._v("能够知道React路由的匹配模式")])]),t._v(" "),e("h2",{attrs:{id:"react路由介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react路由介绍"}},[t._v("#")]),t._v(" React路由介绍")]),t._v(" "),e("p",[t._v("现代的前端应用大多数是SPA（单页应用程序），也就是只有一个HTML页面的应用程序。因为它的用户体验更好、对服务器压力更小，所以更受欢迎。为了有效的使用单个页面来管理多页面的功能，前端路由应运而生。")]),t._v(" "),e("ul",[e("li",[t._v("前端路由功能：让用户从一个视图（页面）导航到另一个视图（页面）")]),t._v(" "),e("li",[t._v("前端路由是一套映射规则，在React中，是URL路径与组件的对应关系")]),t._v(" "),e("li",[t._v("使用React路由简单来说，就是配置路径和组件")])]),t._v(" "),e("h2",{attrs:{id:"路由的基本使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由的基本使用"}},[t._v("#")]),t._v(" 路由的基本使用")]),t._v(" "),e("h3",{attrs:{id:"使用步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用步骤"}},[t._v("#")]),t._v(" 使用步骤")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("安装： yarn add react-router-dom")]),t._v(" "),e("ul",[e("li",[t._v("如果没有安装yarn工具的，需要先全局安装一下yarn：npm install -g yarn")])])]),t._v(" "),e("li",[e("p",[t._v("导入路由的三个核心组件： Router / Route / Link")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import {BrowserRouter as Router, Route, Link} from 'react-router-dom'\n")])])])]),t._v(" "),e("li",[e("p",[t._v("使用Router 组件包裹整个应用")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/Router.png",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("使用Link组件作为导航菜单（路由入口）")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/link%E5%85%A5%E5%8F%A3.png",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("使用Route组件配置路由规则和要展示的组件（路由出口）")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/route.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"常用组件说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用组件说明"}},[t._v("#")]),t._v(" 常用组件说明")]),t._v(" "),e("ul",[e("li",[t._v("**Router组件：**包裹整个应用，一个React应用只需要使用一次\n"),e("ul",[e("li",[t._v("两种常用的Router： HashRouter和BrowserRouter")]),t._v(" "),e("li",[t._v("HashRouter： 使用URL的哈希值实现 （localhost:3000/#/first）")]),t._v(" "),e("li",[t._v("推荐 BrowserRouter：使用H5的history API实现（localhost3000/first）")])])]),t._v(" "),e("li",[t._v("**Link组件：**用于指定导航链接（a标签）\n"),e("ul",[e("li",[t._v("最终Link会编译成a标签，而to属性会被编译成 a标签的href属性")])])]),t._v(" "),e("li",[t._v("**Route组件：**指定路由展示组件相关信息\n"),e("ul",[e("li",[t._v("path属性：路由规则，这里需要跟Link组件里面to属性的值一致")]),t._v(" "),e("li",[t._v("component属性：展示的组件")]),t._v(" "),e("li",[t._v("Route写在哪，渲染出来的组件就在哪")])])])]),t._v(" "),e("h3",{attrs:{id:"路由的执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由的执行过程"}},[t._v("#")]),t._v(" 路由的执行过程")]),t._v(" "),e("ul",[e("li",[t._v("当我们点击Link组件的时候，修改了浏览器地址栏中的url")]),t._v(" "),e("li",[t._v("React路由监听地址栏url的变化")]),t._v(" "),e("li",[t._v("React路由内部遍历所有的Route组件，拿着Route里面path规则与pathname进行匹配")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/route%E5%8C%B9%E9%85%8D.png",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("当路由规则（path）能够匹配地址栏中的pathname时，就展示该Route组件的内容")])]),t._v(" "),e("h3",{attrs:{id:"编程式导航"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编程式导航"}},[t._v("#")]),t._v(" 编程式导航")]),t._v(" "),e("ul",[e("li",[t._v("**场景：**点击登陆按钮，登陆成功后，通过代码跳转到后台首页，如何实现？")]),t._v(" "),e("li",[t._v("**编程式导航：**通过JS代码来实现页面跳转")]),t._v(" "),e("li",[t._v("history是React路由提供的，用于获取浏览器历史记录的相关信息")]),t._v(" "),e("li",[t._v("**push(path)：**跳转到某个页面，参数path表示要跳转的路径")]),t._v(" "),e("li",[t._v("go(n)：前进或后退功能，参数n表示前进或后退页面数量")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"默认路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认路由"}},[t._v("#")]),t._v(" 默认路由")]),t._v(" "),e("ul",[e("li",[t._v("现在的路由都是通过点击导航菜单后展示的，如果进入页面的时候就主动触发路由呢")]),t._v(" "),e("li",[t._v("默认路由：表示进入页面时就会匹配的路由")]),t._v(" "),e("li",[t._v("默认路由：只需要把path设置为 "),e("code",[t._v("'/'")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"匹配模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#匹配模式"}},[t._v("#")]),t._v(" 匹配模式")]),t._v(" "),e("h4",{attrs:{id:"模糊匹配模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模糊匹配模式"}},[t._v("#")]),t._v(" 模糊匹配模式")]),t._v(" "),e("ul",[e("li",[t._v("当Link组件的to属性值为 '/login' 时候，为什么默认路由也被匹配成功？")]),t._v(" "),e("li",[t._v("默认情况下，React路由是模糊匹配模式")]),t._v(" "),e("li",[t._v("模糊匹配规则：只要pathname以path开头就会匹配成功")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F.png",alt:""}})]),t._v(" "),e("h4",{attrs:{id:"精准匹配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#精准匹配"}},[t._v("#")]),t._v(" 精准匹配")]),t._v(" "),e("ul",[e("li",[t._v("默认路由认可情况下都会展示，如果避免这种问题？")]),t._v(" "),e("li",[t._v("给Route组件添加exact属性，让其变为"),e("strong",[t._v("精准匹配模式")])]),t._v(" "),e("li",[t._v("精确匹配：只有当path和pathname完全匹配时才会展示改路由")])]),t._v(" "),e("p",[e("img",{attrs:{src:"images/%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"小结-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),e("ul",[e("li",[t._v("React路由可以有效的管理多个视图实现 SPA")]),t._v(" "),e("li",[t._v("路由先需要通过安装")]),t._v(" "),e("li",[t._v("Router组件包裹整个应用，只需要使用一次")]),t._v(" "),e("li",[t._v("Link组件是入口，Route组件是出口")]),t._v(" "),e("li",[t._v("通过props.history实现编程式导航")]),t._v(" "),e("li",[t._v("默认是模糊匹配，添加exact编程精确匹配")]),t._v(" "),e("li",[t._v("React路由的一切都是组件，可以像思考组件一样思考路由")])])])}),[],!1,null,null,null);a.default=s.exports}}]);